{"version":3,"file":"markdownItFurigana.modern.js","sources":["../lib/ruby.js","../lib/furigana.js","../index.js"],"sourcesContent":["\n\n/**\n * Parses the [body]{toptext} syntax and returns\n * the body and toptext parts. These are then processed\n * in furigana.js and turned into \\<ruby\\> tags by\n * the {@link addTag} function.\n *\n * @param {*} state Markdown-it's inline state.\n * @returns {{body: string, toptext: string, nextPos: int}}\n * body: the main text part of the \\<ruby\\> tag.\n *\n * toptext: the top part of the \\<ruby\\> tag.\n *\n * nextPos: index of the next character in the markdown source.\n */\nexport function parse(state) {\n  if (state.src.charAt(state.pos) !== '[') {\n    return null;\n  }\n\n  const bodyStartBracket = state.pos;\n  const bodyEndBracket = state.src.indexOf(']', bodyStartBracket);\n\n  if (\n    bodyEndBracket === -1 ||\n    bodyEndBracket >= state.posMax ||\n    state.src.charAt(bodyEndBracket + 1) !== '{'\n  ) {\n    return null;\n  }\n\n  const toptextStartBracket = bodyEndBracket + 1;\n  const toptextEndBracket = state.src.indexOf('}', toptextStartBracket);\n\n  if (toptextEndBracket === -1 || toptextEndBracket >= state.posMax) {\n    return null;\n  }\n\n  const body = state.src.slice(bodyStartBracket + 1, bodyEndBracket);\n  const toptext = state.src.slice(toptextStartBracket + 1, toptextEndBracket);\n  if (body.trim() === '' || toptext.trim() === '') {\n    return null;\n  }\n\n  return {\n    body: body,\n    toptext: toptext,\n    nextPos: toptextEndBracket + 1\n  };\n}\n\n/**\n * Takes as content a flat array of main parts of\n * the ruby, each followed immediately by the text\n * that should show up above these parts.\n *\n * That content is then stored in its appropriate\n * representation in a markdown-it's inline state,\n * eventually resulting in a \\<ruby\\> tag.\n *\n * This function also gives you the option to add\n * fallback parentheses, should the \\<ruby\\>\n * tag be unsupported. In that case, the top text\n * of the ruby will instead be shown after the main\n * text, surrounded by these parentheses.\n *\n * @example\n * addTag(state, ['猫', 'ねこ', 'と', '', '犬', 'いぬ'])\n * // markdown-it will eventually produce a <ruby> tag\n * // with 猫と犬 as its main text, with ねこ corresponding\n * // to the 猫 kanji, and いぬ corresponding to the 犬 kanji.\n *\n * @param {*} state Markdown-it's inline state.\n * @param {string[]} content Flat array of main parts of\n *     the ruby, each followed by the text that should\n *     be above those parts.\n * @param {string} fallbackParens Parentheses to use\n *     as a fallback if the \\<ruby\\> tag happens to be\n *     unsupported. Example value: \"【】\".\n *     \"\" disables fallback parentheses.\n */\nexport function addTag(state, content, fallbackParens = '') {\n  function pushText(text) {\n    const token = state.push('text', '', 0);\n    token.content = text;\n  }\n\n  state.push('ruby_open', 'ruby', 1);\n\n  for (let i = 0; i < content.length; i += 2) {\n    const body = content[i];\n    const toptext = content[i + 1];\n\n    pushText(body);\n\n    if (toptext === '') {\n      state.push('rt_open', 'rt', 1);\n      state.push('rt_close', 'rt', -1);\n      continue;\n    }\n\n    if (fallbackParens !== '') {\n      state.push('rp_open', 'rp', 1);\n      pushText(fallbackParens.charAt(0));\n      state.push('rp_close', 'rp', -1);\n    }\n\n    state.push('rt_open', 'rt', 1);\n    pushText(toptext);\n    state.push('rt_close', 'rt', -1);\n\n    if (fallbackParens !== '') {\n      state.push('rp_open', 'rp', 1);\n      pushText(fallbackParens.charAt(1));\n      state.push('rp_close', 'rp', -1);\n    }\n  }\n\n  state.push('ruby_close', 'ruby', -1);\n}\n\n","\n\nimport { addTag, parse } from './ruby.js';\n\nconst kanaRegex = /[\\u3040-\\u3096\\u30a1-\\u30fa\\uff66-\\uff9fー]/;\nconst kanjiRegex = /[\\u3400-\\u9faf]/;\n\n/**\n * Furigana is marked using the [body]{furigana} syntax.\n * First step, performed by bodyToRegex, is to convert\n * the body to a regex, which can then be used to pattern\n * match on the furigana.\n *\n * In essence, every kanji needs to be converted to a\n * pattern similar to \".?\", so that it can match some kana\n * from the furigana part. However, this alone is ambiguous.\n * Consider [可愛い犬]{かわいいいぬ}: in this case there are\n * three different ways to assign furigana in the body.\n *\n * Ambiguities can be resolved by adding separator characters\n * in the furigana. These are only matched at the\n * boundaries between kanji and other kanji/kana.\n * So a regex created from 可愛い犬 should be able to match\n * か・わい・い・いぬ, but a regex created from 美味しい shouldn't\n * be able to match おいし・い.\n *\n * For purposes of this function, only ASCII dot is a\n * separators. Other characters are converted to dots in\n * the {@link cleanFurigana} function.\n *\n * The notation [可愛い犬]{か・わい・い・いぬ} forces us to\n * have separate \\<rt\\> tags for 可 and 愛. If we want to\n * indicate that か corresponds to 可 and わい corresponds to 愛\n * while keeping them under a single \\<rt\\> tag, we can use\n * a combinator instead of a separator, e.g.:\n * [可愛い犬]{か+わい・い・いぬ}\n *\n * For purposes of this function, only ASCII plus is a\n * combinator. Other characters are converted to pluses in\n * the {@link cleanFurigana} function.\n *\n * @param {string} body The non-furigana part.\n * @returns {(null|RegExp)} Null if the body contains no hiragana\n *     or kanji, otherwise a regex to be used on the furigana.\n */\nfunction bodyToRegex(body) {\n  let regexStr = '^';\n  let lastType = 'other';\n\n  const combinatorOrSeparatorGroup = '([+.]?)';\n  const combinatorOrSeparator = '[+.]?';\n  const combinatorOnly = '\\\\.?';\n  const furiganaGroup = '([^+.]+)';\n\n  for (let i = 0; i < body.length; i++) {\n    const c = body.charAt(i);\n    if (kanjiRegex.test(c)) {\n      if (lastType === 'kanji') {\n        regexStr += combinatorOrSeparatorGroup;\n      } else if (lastType === 'kana') {\n        regexStr += combinatorOrSeparator;\n      }\n\n      regexStr += furiganaGroup;\n      lastType = 'kanji';\n    } else if (kanaRegex.test(c)) {\n      if (lastType === 'kanji') {\n        regexStr += combinatorOrSeparator;\n      }\n      regexStr += c;\n      lastType = 'kana';\n    } else {\n      if (lastType !== 'other') {\n        regexStr += combinatorOnly;\n      }\n      lastType = 'other';\n    }\n  }\n\n  if (regexStr === '') {\n    return null;\n  }\n  return new RegExp(regexStr + '$');\n}\n\n/**\n * For a ruby tag specified as [body]{toptext}, tries to find\n * the appropriate furigana in the toptext for every kanji\n * in the body.\n *\n * The result is a flat array where each part of the body\n * is followed by its corresponding furigana. Or, if no\n * such correspondence can be found, just [body, toptext]\n * is returned.\n *\n * As a special case, if toptext starts with = or ＝, the\n * pattern-matching functionality is disabled, and only\n * [body, toptext-without-the-equals-sign] is returned.\n *\n * @example\n * r = matchFurigana('美味しいご飯', 'おいしいごはん')\n * assert(r == ['美味', 'おい', 'しいご', '', '飯', 'はん'])\n *\n * @example\n * // no match\n * r = matchFurigana('食べる', 'たべべ')\n * assert(r == ['食べる', 'たべべ'])\n *\n * @example\n * // disabled pattern matching\n * r = matchFurigana('食べる', '＝たべる')\n * assert(r == ['食べる', 'たべる'])\n *\n * @param {string} body\n * @param {string} toptext\n * @returns {string[]} Flat array of parts of the body followed\n *     by their corresponding furigana, or just [body, toptext]\n *     if no such correspondence exists.\n */\nfunction matchFurigana(body, toptext, options) {\n  if (/^[=＝]/.test(toptext)) {\n    return [ body, toptext.slice(1) ];\n  }\n\n  const bodyRegex = bodyToRegex(body);\n  if (bodyRegex === null) {\n    return [ body, toptext ];\n  }\n\n  const match = bodyRegex.exec(cleanFurigana(toptext, options));\n  if (match === null) {\n    return [ body, toptext ];\n  }\n\n  let result = [];\n  let curBodyPart = '';\n  let curToptextPart = '';\n  let matchIndex = 1;\n  let lastType = 'other';\n  for (let i = 0; i < body.length; i++) {\n    const c = body.charAt(i);\n\n    if (kanjiRegex.test(c)) {\n      if (lastType === 'kana' || lastType === 'other') {\n        if (curBodyPart !== '') {\n          result.push(curBodyPart, curToptextPart);\n        }\n        curBodyPart = c;\n        curToptextPart = match[matchIndex++];\n        lastType = 'kanji';\n        continue;\n      }\n\n      const connection = match[matchIndex++];\n      if (connection === '+' || connection === '') {\n        curBodyPart += c;\n        curToptextPart += match[matchIndex++];\n      } else {\n        result.push(curBodyPart, curToptextPart);\n        curBodyPart = c;\n        curToptextPart = match[matchIndex++];\n      }\n    } else {\n      if (lastType !== 'kanji') {\n        curBodyPart += c;\n        continue;\n      }\n\n      result.push(curBodyPart, curToptextPart);\n      curBodyPart = c;\n      curToptextPart = '';\n\n      if (kanaRegex.test(c)) {\n        lastType = 'kana';\n      } else {\n        lastType = 'other';\n      }\n    }\n  }\n\n  result.push(curBodyPart, curToptextPart);\n  return result;\n}\n\n/**\n * \"Cleans\" the furigana by converting all allowed\n * separators to ASCII dots and all allowed combinators\n * to ASCII pluses.\n *\n * The meaning of \"separator\" and \"combinator\" is\n * described in the {@link bodyToRegex} function.\n *\n * @param {string} furigana\n * @returns {string} Clean version of the furigana.\n */\nfunction cleanFurigana(furigana, options) {\n  furigana = furigana.replace(options.separatorRegex, '.');\n  furigana = furigana.replace(options.combinatorRegex, '+');\n  return furigana;\n}\n\n/**\n * Parallel to the {@link matchFurigana} function,\n * but instead of doing any matching it just adds\n * toptext to every character of the body. This\n * is intended to be used for emphasis dots, like\n * you sometimes see in manga.\n *\n * For this, toptext is expected to start with\n * an asterisk (ASCII or full-width), and the actual\n * marker that should be placed after every character\n * should follow afterward.\n *\n * If no marker is provided, a circle (●) is used.\n *\n * Since this is meant to mimic the return value of the\n * {@link matchFurigana} function, the result is just an array\n * of characters from the body followed by the marker.\n *\n * @example\n * r = rubifyEveryCharacter('だから', '*')\n * assert(r == ['だ', '●', 'か', '●', 'ら', '●'])\n *\n * @example\n * r = rubifyEveryCharacter('だから', '*+')\n * assert(r == ['だ', '+', 'か', '+', 'ら', '+'])\n *\n * @param {string} body\n * @param {string} toptext\n * @returns {string[]} Flat array of characters of the body,\n *     each one followed by the marker as specified in toptext.\n */\nfunction rubifyEveryCharacter(body, toptext) {\n  let topmark = toptext.slice(1);\n  if (topmark === '') {\n    topmark = '●';\n  }\n\n  let result = [];\n  for (let c of body) {\n    result.push(c, topmark);\n  }\n  return result;\n}\n\n/**\n * Returns a function that's compatible for use with\n * markdown-it's inline ruler. The function is further\n * customizable via the options.\n *\n * Available options:\n * - fallbackParens: fallback parentheses for the resulting\n *     \\<ruby\\> tags. Default value: \"【】\".\n * - extraSeparators: additional characters that can be used\n *     to separate furigana. Empty by default. Example value:\n *     \"_-*\".\n *\n *     The characters that are already hard-coded as\n *     separator characters are any kind of space, as well as\n *     these: \".．。・|｜/／\".\n * - extraCombinators: additional characters that can be used\n *     to indicate a kanji boundary without actually splitting\n *     the furigana. Empty by default.\n *\n *     The characters that are already hard-coded as\n *     combinator characters are '+' and '＋'.\n *\n * @param {Object} options\n */\nfunction furigana(options = {}) {\n  options.fallbackParens = options.fallbackParens || '【】';\n\n  options.extraSeparators = (options.extraSeparators || '').replace(\n    /([\\-\\]\\\\])/g,\n    '\\\\$1'\n  );\n  options.extraCombinators = (options.extraCombinators || '').replace(\n    /([\\-\\]\\\\])/g,\n    '\\\\$1'\n  );\n\n  options.separatorRegex = new RegExp(\n    `[\\\\s.．。・|｜/／${options.extraSeparators}]`,\n    'g'\n  );\n  options.combinatorRegex = new RegExp(`[+＋${options.extraCombinators}]`, 'g');\n\n  return function (state, silent) {\n    return process(state, silent, options);\n  };\n}\n\n/**\n * Processes furigana by converting [kanji]{furigana}\n * into required markdown-it tokens. This is meant to be\n * hooked up to markdown-it's inline ruleset.\n *\n * Refer to {@link furigana} for available options.\n *\n * @param {*} state Markdown-it's inline state.\n * @param {boolean} silent If true, no tokens are actually generated.\n * @param {Object} options\n * @returns {boolean} Whether the function successfully processed the text.\n */\nfunction process(state, silent, options) {\n  const ruby = parse(state);\n  if (ruby === null) {\n    return false;\n  }\n\n  state.pos = ruby.nextPos;\n\n  if (silent) {\n    return true;\n  }\n\n  const emphasisDotsIndicatorRegex = /^[*＊].?/;\n  if (emphasisDotsIndicatorRegex.test(ruby.toptext)) {\n    const content = rubifyEveryCharacter(ruby.body, ruby.toptext);\n    addTag(state, content);\n  } else {\n    const content = matchFurigana(ruby.body, ruby.toptext, options);\n    addTag(state, content, options.fallbackParens);\n  }\n\n  return true;\n}\n\n\nexport default furigana;\n\n","\nimport fugirana from './lib/furigana.js';\n\nexport default function (md, options) {\n  md.inline.ruler.push('furigana', fugirana(options));\n}\n"],"names":["parse","state","src","charAt","pos","bodyStartBracket","bodyEndBracket","indexOf","posMax","toptextStartBracket","toptextEndBracket","body","slice","toptext","trim","nextPos","addTag","content","fallbackParens","pushText","text","token","push","i","length","kanaRegex","kanjiRegex","bodyToRegex","regexStr","lastType","combinatorOrSeparatorGroup","combinatorOrSeparator","combinatorOnly","furiganaGroup","c","test","RegExp","matchFurigana","options","bodyRegex","match","exec","cleanFurigana","result","curBodyPart","curToptextPart","matchIndex","connection","furigana","replace","separatorRegex","combinatorRegex","rubifyEveryCharacter","topmark","extraSeparators","extraCombinators","silent","process","ruby","emphasisDotsIndicatorRegex","md","inline","ruler","fugirana"],"mappings":"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"}